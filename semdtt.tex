\documentclass[a4paper]{article}
\usepackage[margin=1in]{geometry}

\usepackage{preamble}
\usepackage{semdtt-macros}
\usepackage{minted}
\usepackage[final]{showkeys}

\title{Category with families}
\author{Frank Tsai}

\begin{document}

\maketitle

These are my personal notes on and expositions of \cite{Hofmann1997}.
Any mistake is my own.

\section{Introduction}\label{sec:intro}

% Last week, Gianluca talked about the syntactic aspect of type theory.
% Today, we will briefly review some typical types in dependent type theory, and introduce a semantic framework called \emph{category with families}.

Semantics is a compositional assignment of mathematical objects to syntactic objects; syntactic objects are \emph{interpreted} as objects in the semantic domain.
A reasonable question that one may ask is: why do we care about semantics?
Besides mathematical curiosity, semantic methods have been applied to show numerous independence results.
On a more practical side, semantic methods can be applied to show syntactic properties such as normalization and decidability of type checking.
Indeed, one can argue that the latter property is nonnegotiable in any practical computer implementation of type theory.

Hofmann \cite{Hofmann1997} developed an abstract semantic framework --- called \emph{category with families} --- upon which a single interpretation function can be defined once and for all.
Then, to show that a theory can be interpreted in a given semantic domain, one shows that the given semantic domain fits in such a framework.

% I will start off my presentation with the structural aspect of dependent type theory; in particular, we will discuss the notions of contexts, substitutions, and context extensions.

% \section{Dependent type theory}\label{sec:dtt}

% A dependent type theory is presented by its \emph{judgments}; for instance, the typehood of $\sigma$ is expressed by the judgment $\typeJudg{\sigma}$ and the elementhood of $t$ in $\sigma$ is expressed by the judgment $t : \sigma$.
% The elementhood of an open term depends on the types of its open variables; for instance, we cannot make the judgment $x + y : \bN$ unless we already know that $x : \bN$ and $y : \bN$.
% Since types can depend on values, the typehood of an expression such as $\sigma(x)$ must also be made relative to a list of \emph{variable declarations}.
% Such lists of declarations are called \emph{contexts}.

% More complex notions of context exist in the literature, but for our purpose, a context is a list of well-formed variable declarations of the form $x_1 : \sigma_1, x_2 : \sigma_2, \ldots, x_n : \sigma_n$ where each type $\sigma_i$ is a type in the context $x_1 : \sigma_1,\ldots, x_{i-1} : \sigma_{i-1}$.
% The judgment $\ctxJudg{\Gamma}$ expresses that $\Gamma$ is a well-formed context.

% Finally, we have a notion of \emph{definitional equality} built into the theory; for example, we'd like to regard $0 : \bN$ and $0 + 0 : \bN$ as definitionally equal terms and $\typeJudg{\sigma(0)}$ and $\typeJudg{\sigma(0+0)}$ as definitionally equal types.
% We express these equalities via the judgments $0 = 0 + 0 : \bN$ and $\typeJudg{\sigma(0) = \sigma(0+0)}$ respectively.

% To summarize, there are six kinds of judgments:
% \begin{align*}
%   &\vdash \ctxJudg{\Gamma} && \text{$\Gamma$ is a well-formed context}&&\\
%   \Gamma &\vdash \typeJudg{\sigma} && \text{$\sigma$ is a type in context $\Gamma$}&&\\
%   \Gamma &\vdash t : \sigma && \text{$t$ is a term of type $\sigma$ in context $\Gamma$}&&\\
%   &\vdash \ctxJudg{\Gamma = \Delta} && \text{$\Gamma$ and $\Delta$ are definitionally equal contexts}&&\\
%   \Gamma &\vdash \typeJudg{\sigma = \tau} && \text{$\sigma$ and $\tau$ are definitionally equal types in context $\Gamma$}&&\\
%   \Gamma &\vdash t = s : \sigma && \text{$t$ and $s$ are definitionally equal terms of type $\sigma$ in context $\Gamma$}&&\\
% \end{align*}


\section{Substitutions}\label{sec:pscm}

In dependent type theory, judgments have to be made with respect to a context.
For example, the judgment
\[
  \typeJudg{\synTypeId(x,1)}
\]
does not make sense without knowing that $x : \NN$.

For us, a context is a finite list of variable declarations.
Note that the order of variable declarations matters in dependent type theory since the type of a variable may depend on a variable declared earlier.
We use the turnstile notation to denote judgments made relative to a context.
The example above can be made under the context $x : \NN$, denoted as follows:
\[
  x : \NN \vdash \typeJudg{\synTypeId(x,1)}
\]

The most fundamental operation that we can perform on variables is \emph{substitution}.
Say, we have a term
\[
  z : \RR^{+} \vdash \lfloor z \rfloor : \NN
\]
We can substitute $\lfloor z \rfloor$ for $x$ in $\typeJudg{\synTypeId(x,1)}$, resulting in $\typeJudg{\synTypeId(\lfloor z \rfloor,1)}$.
This judgment has to be made in an updated context.
\[
  z : \RR^+ \vdash \typeJudg{\synTypeId(\lfloor z \rfloor,1)}
\]
We may regard the substitution along the term $\lfloor z \rfloor$ as a \emph{morphism} from $z : \RR^+$ to $x : \NN$.

\begin{definition}
  Let $\Delta$ and $\Gamma = x_1 : \sigma_1,\ldots,x_n : \sigma_n$ be contexts.
  A \emph{substitution} from $\Delta$ to $\Gamma$ is a sequence of $n$ terms $(t_1,\ldots,t_n)$ such that the following $n$ judgments hold:
  \begin{align*}
    \Delta &\vdash t_1 : \sigma_1\\
    \Delta &\vdash t_2 : \sigma_2[t_1/x_1]\\
      &\ldots\\
    \Delta &\vdash t_n : \sigma_n[t_1/x_1]\ldots[t_{n-1}/x_{n-1}]
  \end{align*}
\end{definition}

\begin{notation}
  Let $\Gamma = x_1 : \sigma_1,\ldots,x_n : \sigma_n$ be a context and $f = (t_1,\ldots,t_n)$ be a substitution.
  If $\Gamma \vdash \typeJudg{\sigma}$ (respectively $\Gamma \vdash t : \sigma$), then we write $\sigma[f]$ (respectively $t[f]$) for the simultaneous substitution $\sigma[t_1/x_1,\ldots,t_n/x_n]$.
\end{notation}

\begin{example}
  For any context $\Gamma$, there exists a unique substitution $()$ from $\Gamma$ to the empty context $\emptyCtx$.
\end{example}

\begin{example}
  If $\Gamma = x_1 : \sigma_1,\ldots,x_{n} : \sigma_n$ is a context and $\Gamma \vdash \typeJudg{\sigma}$ and $x$ is a fresh variable, then $(x_1,\ldots,x_n)$ is a substitution $\Gamma, x : \sigma \vdash \ctxExt(\Gamma,\sigma) : \Gamma$.
\end{example}

\begin{example}\label{eg:bar}
  For any context $\Gamma = x_1 : \sigma_1,\ldots,x_n : \sigma_n$ and any term $\Gamma \vdash t : \sigma$ we can form a substitution $\Gamma \vdash (x_1,\ldots,x_n,t) : \Gamma, x : \sigma$.
  We write $\ctxSec{t} := (x_1,\ldots,x_n,t)$.
\end{example}

\begin{example}
  For any context $\Gamma = x_1 : \sigma_1,\ldots,x_n : \sigma_n$, the identity substitution $\Gamma \vdash \id{\Gamma} : \Gamma$ is given by $\id{\Gamma} = (x_1,\ldots,x_n)$.
\end{example}

\begin{example}
  Substitutions can be composed in the usual way.
  Let $\Lambda \vdash g : \Delta$ and $\Delta \vdash f : \Gamma$, where $f = (t_1,\ldots,t_n)$.
  The composition $f \circ g$ is the tuple $(t_1[g],\ldots,t_n[g])$.
  It is clear that $\Lambda \vdash f \circ g : \Gamma$.
\end{example}

\begin{example}\label{eg:weak}
  Let $\Delta \vdash f : \Gamma$.
  There is a substitution $\ctxWkn(f,\sigma)$ in the following configuration:
  % https://q.uiver.app/#q=WzAsNCxbMCwxLCJcXERlbHRhIl0sWzEsMSwiXFxHYW1tYSJdLFsxLDAsIlxcR2FtbWEseDpcXHNpZ21hIl0sWzAsMCwiXFxEZWx0YSx4Olxcc2lnbWFbZl0iXSxbMCwxLCJmIiwyXSxbMiwxLCJcXGN0eEV4dChcXEdhbW1hLFxcc2lnbWEpIl0sWzMsMCwiXFxjdHhFeHQoXFxEZWx0YSxcXHNpZ21hW2ZdKSIsMl0sWzMsMiwiXFxjdHhXa24oZixcXHNpZ21hKSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRvdHRlZCJ9fX1dXQ==
  \[\begin{tikzcd}
      {\Delta,x:\sigma[f]} & {\Gamma,x:\sigma} \\
      \Delta & \Gamma
      \arrow["{\ctxWkn(f,\sigma)}", dotted, from=1-1, to=1-2]
      \arrow["{\ctxExt(\Delta,\sigma[f])}"', from=1-1, to=2-1]
      \arrow["{\ctxExt(\Gamma,\sigma)}", from=1-2, to=2-2]
      \arrow["f"', from=2-1, to=2-2]
    \end{tikzcd}\]
  Explicitly, $\ctxWkn(f,\sigma)$ is given by $(f, x)$.
  The diagram commutes, meaning $\ctxExt(\Gamma,\sigma) \circ \ctxWkn(f,\sigma) = f \circ \ctxExt(\Delta,\sigma[f])$, up to variable renaming.
\end{example}

\begin{proposition}\label{0000}
  Assume $\Pi \vdash h : \Lambda$, $\Lambda \vdash g : \Delta$, and $\Delta \vdash f : \Gamma$.
  Furthermore, let $\Gamma \vdash \typeJudg{\sigma}$ and $\Gamma \vdash t : \sigma$; then the following equations hold (up to variable renaming).
  \begin{align*}
    f \circ \id{\Delta} &= \id{\Gamma} \circ f = f\\
    (f \circ g) \circ h &= f \circ (g \circ h)\\
    \sigma[\id{\Gamma}] &= \sigma\\
    \sigma[f \circ g] &= \sigma[f][g]\\
    t[\id{\Gamma}] &= t\\
    t[f \circ g] &= t[f][g]
  \end{align*}
\end{proposition}

The first two equations suggest that contexts and substitutions form a category, while the remaining equations suggest that substitution is functorial.

% \begin{proposition}
%   The followings hold (up to variable renaming):
%   \begin{enumerate}
%   \item If $\Gamma \vdash f \Rightarrow \Delta$, then $\id{\Delta} \circ f = f = f \circ \id{\Gamma}$.
%   \item If $\Gamma \vdash t : \sigma$, then $\ctxExt(\Gamma,\sigma) \circ \ctxSec{t} = \id{\Gamma}$.
%   \item If $\Gamma \vdash (f,t) \Rightarrow \Delta,x : \sigma$, then $\ctxExt(\Gamma,\sigma) \circ (f, t) = f$ and $x[(f,t)] = t$.
%   \item If $\Gamma \vdash f \Rightarrow \Delta$ and $\vdash \ctxJudg{\Delta,x : \sigma}$ then $\ctxExt(\Delta,\sigma) \circ \ctxWkn(f,x:\sigma) = f \circ \ctxExt(\Gamma,\sigma[f])$.
%   \item If $\Gamma \vdash f \Rightarrow \Delta$ and $\Delta \vdash t : \sigma$, then $\ctxSec{t} \circ f = \ctxWkn(f,x : \sigma) \circ \ctxSec{t[f]}$.
%   \item If $\Gamma \vdash \typeJudg{\sigma}$ and $x$ is fresh, then $\id{\Gamma,x:\sigma} = (\ctxExt(\Gamma,\sigma),x)$.
%   \end{enumerate}
% \end{proposition}

\section{Category with families}\label{sec:cwf}

Building upon \cref{0000}, we can consider any small category with a terminal object as a category of contexts and substitutions.
The terminal object models the empty context.

\begin{scholium}
  A small category with a terminal object contains the data of contexts and substitutions of type theory.
\end{scholium}

To model the following two judgments.
We need to specify a set of types $\Ty{}(\Gamma)$ for each context $\Gamma$ and set of terms $\Tm{}(\Gamma,\sigma)$ for each type $\sigma \in \Ty{}(\Gamma)$.
\begin{mathpar}
  \Gamma \vdash \typeJudg{\sigma}\and
  \Gamma \vdash t : \sigma
\end{mathpar}
Moreover, these families of sets vary with substitutions: given a substitution $\Delta \vdash f : \Gamma$, we must have $\sigma[f] \in \Ty{}(\Delta)$ and $t[f] \in \Tm{}(\Delta,\sigma[f])$.
This models the following judgments:
\begin{mathpar}
  \Delta \vdash \typeJudg{\sigma[f]}\and
  \Delta \vdash t[f] : \sigma[f]
\end{mathpar}

% A category with families \emph{should} contain the following data:
% \begin{enumerate}
% \item a category $\cC$ of semantic contexts and substitutions;
% \item for $\Gamma \in \cC$, a collection $\Ty{\cC}(\Gamma)$ of semantic types;
% \item for $\Gamma \in \cC$ and $\sigma \in \Ty{\cC}(\Gamma)$, a collection $\Tm{\cC}(\Gamma,\sigma)$ of semantic terms.
% \end{enumerate}

% This is the most bare-metal definition; it only accounts for the structural rules common to all systems of dependent types.

Hence if $\cC$ is a category of contexts and substitutions, the set of types and the set of terms form a $\cC$-indexed family.
To formalize this idea, we define the category $\Fam$.

\begin{definition}
  The \emph{category $\Fam$ of families} has, as objects, pairs $(B^0,B^1)$, where $B^0$ is a set and $B^1$ is an $B^0$-indexed family of sets $(B^1_b)_{b \in B^0}$; and, as morphisms, $(B^0,B^1) \to (C^0,C^1)$ pairs $(f^0,f^1)$, where $f^0 : B^0 \to C^0$ is a function and $f^1$ is an $B^0$-indexed family of functions $(f^1_b : B^1_b \to C^1_{f^0(b)})_{b \in B^0}$.
\end{definition}

\begin{scholium}
  Given a category $\cC$ of contexts and substitutions.
  The $\cC$-indexed family of types and terms is specified by a contravariant functor $F : \cC\op \to \Fam$.
\end{scholium}

\begin{notation}
  We write $(\Ty{}, \Tm{}) : \cC\op \to \Fam$ to emphasize that for each context $\Gamma$, the components of $(\Ty{}(\Gamma), \Tm{}(\Gamma))$ are respectively a set of types and an indexed-set of terms.
  We write $\semSubst{\sigma}{f}$ and $\semSubst{t}{f}$ rather than the more cumbersome notations $\Ty{}(f)(\sigma)$ and $\Tm{}(f)_{\semSubst{\sigma}{f}}(t)$.
\end{notation}

The last missing ingredient is context extension: given a context $\Gamma$ and a type $\sigma \in \Ty{}(\Gamma)$ we need to specify a context $\Gamma.\sigma$ to model the variable declaration $\Gamma, x : \sigma$.
We need a substitution $\ctxExt(\Gamma,\sigma) : \Gamma.\sigma \to \Gamma$, so we can extend the context $\Gamma$ with $\sigma$.
Furthermore, we need a term $v \in \Tm{}(\Gamma.\sigma, \semSubst{\sigma}{\ctxExt(\Gamma,\sigma)})$ that plays the role of a variable, so we can model the variable rule:
\[
  \Gamma, x : \sigma \vdash x : \sigma
\]
A candidate for context extension is simply a substitution $f : \Delta \to \Gamma$ equipped with a term $t \in \Tm{}(\Delta, \semSubst{\sigma}{f})$.
\begin{definition}\label{0001}
  The \emph{category of comprehension candidates} $\El(F_{\Gamma,\sigma})$ has, as objects, pairs $(f, s)$, where $f : \Delta \to \Gamma$ is a substitution and $s \in \Tm{}(\Delta,\semSubst{\sigma}{f})$; and, as morphisms, $(f, s) \to (g, t)$ commuting triangles in the following configuration:
  % https://q.uiver.app/#q=WzAsMyxbMSwwLCJcXERlbHRhIl0sWzAsMCwiXFxMYW1iZGEiXSxbMCwxLCJcXEdhbW1hIl0sWzEsMiwiZiIsMl0sWzAsMiwiZyJdLFsxLDAsImgiXV0=
  \[\begin{tikzcd}
      \Lambda & \Delta \\
      \Gamma
      \arrow["h", from=1-1, to=1-2]
      \arrow["f"', from=1-1, to=2-1]
      \arrow["g", from=1-2, to=2-1]
    \end{tikzcd}\]
  such that $\semSubst{t}{h} = s$.
\end{definition}
Among all candidates, we pick the universal one to model context extension.
\begin{definition}
  Let $\sigma \in \Ty{}(\Gamma)$.
  A \emph{comprehension for $\sigma$} is a choice of a terminal object in $\El(F_{\Gamma,\sigma})$.
  Explicitly, this consists of a substitution $\ctxExt(\Gamma,\sigma) : \Gamma.\sigma \to \Gamma$ and a term $v \in \Tm{}(\Gamma.\sigma, \semSubst{\sigma}{\ctxExt(\Gamma,\sigma)})$ such that for any substitution $f : \Delta \to \Gamma$ and any term $t \in \Tm{}(\Delta,\semSubst{\sigma}{f})$, there is a unique substitution $\semComp{f}{t}{} : \Delta \to \Gamma.\sigma$ with $\ctxExt(\Gamma,\sigma) \circ \semComp{f}{t}{} = f$ and $\semSubst{v}{\semComp{f}{t}{}} = t$.
\end{definition}

\begin{notation}
  We write $\ctxExt(\sigma)$ for $\ctxExt(\Gamma,\sigma)$ when $\Gamma$ is obvious.
\end{notation}

The reader familiar with the notion of a category of elements will recognize that \cref{0001} is the category of elements of some contravariant functor.
\begin{exercise}
  Find the contravariant functor $F_{\Gamma,\sigma}$ and deduce that $\sigma$ has a comprehension if and only if $F_{\Gamma,\sigma}$ is representable.
\end{exercise}

\begin{scholium}
  The terminal object in $\El(F_{\Gamma,\sigma})$ models context extension.
\end{scholium}

% For each $\Gamma \in \cC$, we can form the slice category $\Sl{\cC}{\Gamma}$; it is helpful to think of the objects of $\Sl{\cC}{\Gamma}$ as ``extensions'' of $\Gamma$ and morphisms as compatible substitutions between two extensions. 

% Now, given a functor $F : \cC\op \to \Fam$ and a type $\sigma \in \Ty{\cC}(\Gamma)$, we can carve out a functor $F_{\Gamma,\sigma} : \prn{\Sl{\cC}{\Gamma}}\op \to \Set$ that maps each extension $f : \Delta \to \Gamma \in \Sl{\cC}{\Gamma}$ to the set $\Tm{\cC}(\Delta,\semSubst{\sigma}{f})$ and each compatible substitution $g : f' \to f$ to the function $\semSubst{-}{g} : \Tm{\cC}(\Delta,\semSubst{\sigma}{f}) \to \Tm{\cC}(\Delta',\semSubst{\sigma}{f'})$.

% \begin{definition}
%   Let $\cC$ be a category and $F = (\Ty{\cC},\Tm{\cC}) : \cC\op \to \Fam$ be a functor.
%   Given $\Gamma \in \cC$ and $\sigma \in \Ty{\cC}(\Gamma)$, the type $\sigma$ has \emph{comprehension} if there is a universal extension, i.e., $F_{\Gamma,\sigma}$ is representable.
%   \[
%     F_{\Gamma,\sigma} \iso \Hom{\Sl{\cC}{\Gamma}}(-,\ctxExt(\sigma))
%   \]
%   We write $\Gamma.\sigma$ for the domain of $\ctxExt(\sigma)$.
% \end{definition}

We are now ready to define the notion of a category with families.

\begin{definition}
  A \emph{category with families} (CwF) is given by the following data:
  \begin{itemize}
  \item a category $\cC$ with a terminal object;
  \item a functor $F : \cC\op \to \Fam$;
  \item a comprehension for each $\Gamma \in \cC$ and $\sigma \in \Ty{}(\Gamma)$.
  \end{itemize}
\end{definition}

\begin{terminology}
  We refer to the action on morphisms of $F$ as \emph{substitution} as well.
\end{terminology}

\subsection{Examples of categories with families}\label{0003}

\begin{example}
  The category of contexts and substitutions, identified up to definitional equality, has a CwF structure in the following settings:
  \begin{align*}
    \Ty{}(\Gamma) &:= \setNotat{\sigma \mid \Gamma \vdash \typeJudg{\sigma}}\\
    \Tm{}(\Gamma,\sigma) &:= \setNotat{t \mid \Gamma \vdash t : \sigma}
  \end{align*}
  Each substitution $\Delta \vdash f : \Gamma$ is mapped to the usual substitution function $-[f]$.

  The comprehension for $\sigma$ is given by the substitution $\Gamma, x : \sigma \vdash (x_1,\ldots,x_n) : \Gamma$, where $\Gamma = x_1 : \sigma_1,\ldots,x_n : \sigma_n$, and the variable $\Gamma, x : \sigma \vdash x : \sigma$.
\end{example}

\begin{example}
  The category $\TT := \setNotat{\bff \leq \btt}$ of truth values has a CwF structure with the following settings:
  \begin{align*}
    \Ty{}(\bff) &:= \Ty{}(\btt) = \setNotat{\bff,\btt}\\
    \Tm{}(\Gamma,\sigma) &:=
                 \begin{cases}
                   \termObj{\Set} & \text{if $\Gamma \leq \sigma$,}\\
                   \initObj{\Set} & \text{otherwise.}
                 \end{cases}
  \end{align*}
  The comprehension for $\sigma$ is given by $\Gamma \wedge \sigma \leq \Gamma$ and the variable is the trivial element.
\end{example}

\begin{example}\label{0002}
  The category $\Set$ of sets and functions has a CwF structure.
  We can consider a context $\Gamma$ as a set of \emph{stages}; then a type $\sigma$ is a $\Gamma$-indexed set of terms and a term of type $\sigma$ at stage $\gamma$ is an element of $\sigma_{\gamma}$.
  \begin{align*}
    \Ty{}(\Gamma) &:= \setNotat{\prn{\sigma_{\gamma}}_{\gamma \in \Gamma}, \prn{\tau_{\gamma}}_{\gamma \in \Gamma}, \ldots}\\
    \Tm{}(\Gamma,\sigma) &:= \prod_{\gamma \in \Gamma}\sigma_{\gamma}
  \end{align*}
  Here, $\prod_{\gamma \in \Gamma}\sigma_{\gamma}$ is the set-theoretic dependent function space; an element $t \in \prod_{\gamma \in \Gamma}\sigma_{\gamma}$ is a function mapping each $\gamma \in \Gamma$ to an element of $\sigma_{\gamma}$.
  
  Substitution is given by precomposition: for each function $f : \Delta \to \Gamma$, the type $\semSubst{\sigma}{f}$ is given component-wise by $\prn{\semSubst{\sigma}{f}}_{\delta} := \sigma_{f(\delta)}$ and the term $\semSubst{t}{f}$ is given by $\semSubst{t}{f}(\delta) = t(f(\delta))$.
  
  The comprehension for $\sigma$ is given by the first project $\setNotat{(\gamma,x) \mid \gamma \in \Gamma, x \in \sigma_{\gamma}} \to \Gamma$ and the variable $v \in \prod_{(\gamma,x) \in \Gamma.\sigma}\sigma_{f(\gamma,x)}$ is defined by $v(\gamma,x) = x$.
\end{example}

In the set model, there is no non-trivial structure between any two stages because a context, in this case, is \emph{just} a set.

Certain applications require contexts to have additional structures; for example, to study how an object type theory embeds into the Logical Framework, we may take a stage to be a context in the object type theory.
In this scenario, we have to accommodate a \emph{category} of stages.

\begin{example}
  Let $\cT$ be a small category of stages; the presheaf category $\Pr(\cT)$ has a CwF structure that generalizes the set-theoretic one in \cref{0002}.

  Given a context $\Gamma : \cT\op \to \Set$, a type $\sigma$ is a ``$\Gamma$-indexed'' family.
  To make sense of this, we compress $\Gamma$ into its category of elements $\El(\Gamma)$; then a type $\sigma$ is simply a presheaf of terms over $\El(\Gamma)$.
  \begin{align*}
    \Ty{}(\Gamma) &:= \setNotat{\prn{\sigma_{\gamma}}_{\gamma \in \El(\Gamma)}, \prn{\tau_{\gamma}}_{\gamma \in \El(\Gamma)}, \ldots}
  \end{align*}
  Terms, substitution, and comprehensions are given analogously as in \cref{0002}.
\end{example}

\subsection{Terms, sections, and weakening}\label{sec:tas}

The discussion in \cref{sec:pscm} gives us the impression that every term determines a substitution and every substitution of a particular kind corresponds to a term.
We will expose this idea in greater detail in this section.

Let $\cC$ be a CwF and $t \in \Tm{}(\Gamma,\sigma)$.
Note that $t \in \Tm{}(\Gamma,\semSubst{\sigma}{\id{\Gamma}})$ by functoriality.
Then comprehension yields a unique section $\ctxSec{t} := \semComp{\id{\Gamma}}{t}{}$ of the projection $\ctxExt(\Gamma,\sigma)$ such that $\semSubst{v}{\ctxSec{t}} = t$.

% https://q.uiver.app/#q=WzAsMyxbMCwxLCJcXEdhbW1hIl0sWzEsMCwiXFxHYW1tYS5cXHNpZ21hIl0sWzEsMSwiXFxHYW1tYSJdLFswLDEsIlxcY3R4U2Vje3R9IiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoibW9ubyJ9LCJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwyLCIiLDIseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxLDIsIlxcY3R4RXh0KFxcR2FtbWEsXFxzaWdtYSkiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJlcGkifX19XV0=
\[\begin{tikzcd}
    & {\Gamma.\sigma} \\
    \Gamma & \Gamma
    \arrow["{\ctxExt(\Gamma,\sigma)}", two heads, from=1-2, to=2-2]
    \arrow["{\ctxSec{t}}", dashed, tail, from=2-1, to=1-2]
    \arrow[equals, from=2-1, to=2-2]
  \end{tikzcd}\]

Conversely, let $f : \Gamma \to \Gamma.\sigma$ be a section of $\ctxExt(\Gamma,\sigma)$.
This section corresponds to a term $\semSubst{v}{f} \in \Tm{}(\Gamma,\sigma)$.
Then comprehension yields a section $\ctxSec{\semSubst{v}{f}} : \Gamma \to \Gamma.\sigma$.
By uniqueness, $f = \ctxSec{\semSubst{v}{f}}$; hence there is a bijective correspondence between terms and sections.
In light of this correspondence, we may freely regard every term as a substitution.
\begin{notation}
  We write $t$ to mean both the term $t$ and the substitution $\ctxSec{t}$.
\end{notation}

Contexts, types, and terms can be weakened; substitutions are no exceptions.
Given a substitution $f : \Delta \to \Gamma$ and a type $\sigma \in \Ty{}(\Gamma)$, there ought to be a substitution $\ctxWkn(f,\sigma) : \Delta.\semSubst{\sigma}{f} \to \Gamma.\sigma$ that leaves the variable declaration $x : \sigma$ unchanged, while behaves like $f$ on the rest of the context.
Since we want to leave $x : \sigma$ unchanged, we take the variable $v_{\semSubst{\sigma}{f}} \in \Tm{}(\Delta.\semSubst{\sigma}{f},\semSubst{\sigma}{f})$ given by the comprehension for $\semSubst{\sigma}{f}$; then the only substitution that makes sense is $\semComp{f \circ \ctxExt(\semSubst{\sigma}{f})}{v_{\semSubst{\sigma}{f}}}{}$.
% % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXERlbHRhLlxcc2VtU3Vic3R7XFxzaWdtYX17Zn0iXSxbMCwxLCJcXERlbHRhIl0sWzEsMSwiXFxHYW1tYSJdLFsxLDAsIlxcR2FtbWEuXFxzaWdtYSJdLFswLDEsIlxcY3R4RXh0KFxcc2VtU3Vic3R7XFxzaWdtYX17Zn0pIiwyXSxbMSwyLCJmIiwyXSxbMywyLCJcXGN0eEV4dChcXHNpZ21hKSJdLFswLDMsIlxcY3R4V2tuKGYsXFxzaWdtYSkiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0=
% \[\begin{tikzcd}
%     {\Delta.\semSubst{\sigma}{f}} & {\Gamma.\sigma} \\
%     \Delta & \Gamma
%     \arrow["{\ctxWkn(f,\sigma)}", dashed, from=1-1, to=1-2]
%     \arrow["{\ctxExt(\semSubst{\sigma}{f})}"', from=1-1, to=2-1]
%     \arrow["{\ctxExt(\sigma)}", from=1-2, to=2-2]
%     \arrow["f"', from=2-1, to=2-2]
%   \end{tikzcd}\]

\begin{notation}
  To keep the notations clean, we will not spell out substitutions along weakening substitutions, such as $\ctxExt(\sigma)$ and $\ctxWkn(f,\sigma)$, explicitly.
\end{notation}

% \begin{proposition}
%   Let $\cC$ be a CwF, $f : B \to \Gamma$, and $\sigma \in \Ty{\cC}{\Gamma}$.
%   The following square is a pullback.
%   % https://q.uiver.app/#q=WzAsNCxbMCwxLCJCIl0sWzEsMSwiXFxHYW1tYSJdLFsxLDAsIlxcR2FtbWEuXFxzaWdtYSJdLFswLDAsIkIuXFxzZW1TdWJzdHtcXHNpZ21hfXtmfSJdLFswLDEsImYiLDJdLFszLDAsIlxcY3R4UChcXHNlbVN1YnN0e1xcc2lnbWF9e2Z9KSIsMl0sWzIsMSwiXFxjdHhQKFxcc2lnbWEpIl0sWzMsMiwiXFxjdHhRKGYsXFxzaWdtYSkiXSxbMywxLCIiLDEseyJzdHlsZSI6eyJuYW1lIjoiY29ybmVyIn19XV0=
%   \[\begin{tikzcd}
%       {B.\semSubst{\sigma}{f}} & {\Gamma.\sigma} \\
%       B & \Gamma
%       \arrow["{\ctxWkn(f,\sigma)}", from=1-1, to=1-2]
%       \arrow["{\ctxExt(\semSubst{\sigma}{f})}"', from=1-1, to=2-1]
%       \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=2-2]
%       \arrow["{\ctxExt(\sigma)}", from=1-2, to=2-2]
%       \arrow["f"', from=2-1, to=2-2]
%     \end{tikzcd}\]
% \end{proposition}

% \subsection{Interpretation of the syntax}\label{sec:iots}
% Let $\cC$ be a CwF, we define partial interpretation functions for pre-contexts, pre-terms, and pre-types simultaneously.
% The function is undefined if its argument is either ill-formed or underivable.
% \begin{align*}
%   \intp{\ctx}{\emptyCtx} &= \termObj{\cC}\\
%   \intp{\ctx}{\Gamma, x : \sigma} &= \intp{\ctx}{\Gamma}.\intp{\ty}{\Gamma;\sigma}\\
%   \intp{\tm}{\Gamma, x : \sigma; x} &= v_{\intp{\ty}{\Gamma;\sigma}}\\
%   \intp{\tm}{\Gamma, x : \sigma, y : \tau} &= \semSubst{\intp{\tm}{\Gamma, x : \sigma; x}}{\ctxExt(\intp{\ty}{\Gamma, x : \sigma; \tau})}
% \end{align*}
% To define $\intp{\ty}{-}$, $\cC$ must be equipped with appropriate constants.

\subsection{Interpreting types}\label{sec:stf}

% To define $\intp{\ty}{-}$, $\cC$ must be equipped with appropriate constants.

So far, we have only defined how to interpret contexts and substitutions, which is insufficient for any interesting type theory, \ie a type theory with types.
In this section, we will define the interpretations of types common found in Martin-L\"of type theories.

\subsubsection{The empty type}\label{0005}

\begin{mathpar}
  \ebrule[$\synTypeEmpty$-F]{
    \infer0{\vdash \typeJudg{\synTypeEmpty}}
  }\and
  \ebrule[$\synTypeEmpty$-E]{
    \hypo{\Gamma, x : \synTypeEmpty \vdash \typeJudg{\tau}}
    \infer1{\Gamma, x : \synTypeEmpty \vdash \synIndEmpty_{\tau}(x) : \tau}
  }
\end{mathpar}

\begin{definition}
  A CwF $\cC$ supports the empty type if the following data are given:
  \begin{itemize}
  \item \emph{formation}: a type $\typeEmpty \in \Ty{}(\termObj{\cC})$;
  \item \emph{elimination}: for each type $\tau \in \Ty{}(\Gamma.\typeEmpty)$, a term $\indEmpty_{\tau} \in \Tm{}(\Gamma.\typeEmpty,\tau)$.
  \end{itemize}
  The eliminator is required to be stable under substitution: for any $f : \Delta \to \Gamma$, $\indEmpty_{\semSubst{\tau}{f}} = \semSubst{\indEmpty_{\tau}}{f}$.
\end{definition}

\begin{example}
  The term model supports the empty type with the following settings:
  \begin{align*}
    \typeEmpty &:= \synTypeEmpty\\
    \indEmpty_{\tau} &:= \synIndEmpty_{\tau}(x)
  \end{align*}
  where $x : \synTypeEmpty$ is a free variable.
\end{example}

\begin{example}\label{000A}
  The truth value model supports the empty type with the following settings:
  \begin{align*}
    \typeEmpty &:= \bff\\
    \indEmpty_{\tau} &:= *
  \end{align*}
\end{example}

\begin{remark}
  This is the only possible interpretation of $\synTypeEmpty$ in the truth value model since we need to ensure that $\Tm{}(\Gamma.\typeEmpty,\tau)$ is nonempty for any $\tau$.
\end{remark}

\begin{example}
  The set model supports the empty type with the following settings:
  \begin{align*}
    \typeEmpty_{\gamma} &:= \varnothing\\
    \indEmpty_{\tau} &:= \bang
  \end{align*}
  where $\bang$ is the unique function mapping out of the empty set.
\end{example}

\subsubsection{The unit type}\label{0004}

\begin{mathpar}
  \ebrule[$\synTypeUnit$-F]{
    \infer0{\vdash \typeJudg{\synTypeUnit}}
  }\and
  \ebrule[$\synTypeUnit$-I]{
    \infer0{\vdash \star : \synTypeUnit}
  }\and
  \ebrule[$\synTypeUnit$-E]{
    \hypo{\Gamma, x : \synTypeUnit \vdash \typeJudg{\tau}}
    \hypo{\Gamma \vdash s : \tau[\star/x]}
    \infer2{\Gamma, x : \synTypeUnit \vdash \synIndUnit(x,s) : \tau}
  }\and
  \ebrule[$\synTypeUnit$-$\beta$]{
    \hypo{\Gamma, x : \synTypeUnit \vdash \typeJudg{\tau}}
    \hypo{\Gamma \vdash s : \tau[\star/x]}
    \infer2{\Gamma \vdash \synIndUnit(\star,s) = s : \tau[\star/x]}
  }%\and
  % \ebrule[$\synTypeUnit$-$\eta$]{
  %   \hypo{\Gamma \vdash u : \synTypeUnit}
  %   \infer1{\Gamma \vdash u = \star : \synTypeUnit}
  % }
\end{mathpar}

\begin{definition}
  A CwF $\cC$ supports the unit type if the following data are given:
  \begin{itemize}
  \item \emph{formation}: a type $\typeUnit \in \Ty{}(\termObj{\cC})$;
  \item \emph{introduction}: a term $\semStar \in \Tm{}(\termObj{\cC},\typeUnit)$;
  \item \emph{elimination}: for each type $\tau \in \Ty{}(\Gamma.\typeUnit)$, a function $\indUnit_{\tau} : \Tm{}(\Gamma,\semSubst{\tau}{\semStar}) \to \Tm{}(\Gamma.\typeUnit,\tau)$.
  \end{itemize}
  These data are subject to the following equations:
  \begin{itemize}
  \item \emph{$\beta$-law}: $\semSubst{\indUnit(s)}{\semStar} = s$;
  \item \emph{stability under substitution}: for any morphism $f : \Delta \to \Gamma$, $\semSubst{\indUnit_{\tau}(s)}{f} = \indUnit_{\semSubst{\tau}{f}}(\semSubst{s}{f})$.
  \end{itemize}
\end{definition}

\begin{example}
  The term model supports the unit type with the following settings:
  \begin{align*}
    \typeUnit &:= \synTypeUnit\\
    \semStar &:= \star\\
    \indUnit_{\tau}(s) &:= \synIndUnit(x,s)
  \end{align*}
  where $x : \synTypeUnit$ is a free variable.
\end{example}

\begin{example}\label{0009}
  The truth value model supports the unit type with the following settings:
  \begin{align*}
    \typeUnit &:= \btt\\
    \semStar &:= *\\
    \indUnit_{\tau}(s) &:= \bang
  \end{align*}
\end{example}

\begin{remark}
  This is the only interpretation of the unit type in the truth value model since we need to ensure that $\Tm{}(\termObj{\TT},\typeUnit)$ is nonempty.
\end{remark}

\begin{example}
  The set model supports the unit type with the following settings:
  \begin{align*}
    \typeUnit_{\gamma} &:= \termObj{\Set}\\
    \semStar &:= \id{\termObj{\Set}}\\
    \indUnit_{\tau}(s)(\gamma,*) &:= *
  \end{align*}
  where $*$ is the unique element of $\termObj{\Set}$.
\end{example}

\subsubsection{The natural number type}\label{0006}

\begin{mathpar}
  \ebrule[$\NN$-F]{
    \infer0{\vdash \typeJudg{\NN}}
  }\and
  \ebrule[$\NN$-I$_z$]{
    \infer0{\vdash 0 : \NN}
  }\and
  \ebrule[$\NN$-I$_{\synSuc}$]{
    \hypo{\Gamma \vdash u : \NN}
    \infer1{\Gamma \vdash \synSuc(u) : \NN}
  }\and
  \ebrule[$\NN$-E]{
    \hypo{
      \begin{matrix}
        \Gamma, x : \NN \vdash \typeJudg{\tau}\\
        \Gamma \vdash s : \tau[0/x]
      \end{matrix}
    }
    \hypo{\Gamma, y : \NN, p : \tau[y/x] \vdash t : \tau[\synSuc(y)/x]}
    \infer2{\Gamma, n : \NN \vdash \synIndN(n,s,t) : \tau[n/x]}
  }\and
  \ebrule[$\NN$-$\beta_1$]{
    \hypo{\Gamma, x : \NN \vdash \typeJudg{\tau}}
    \hypo{\Gamma \vdash s : \tau[0/x]}
    \hypo{\Gamma, y : \NN, p : \tau[y/x] \vdash t : \tau[\synSuc(y)/x]}
    \infer3{\Gamma \vdash \synIndN(0,s,t) = s : \tau[0/x]}
  }\and
  \ebrule[$\NN$-$\beta_2$]{
    \hypo{\Gamma, x : \NN \vdash \typeJudg{\tau}}
    \hypo{\Gamma \vdash s : \tau[0/x]}
    \hypo{\Gamma, y : \NN, p : \tau[y/x] \vdash t : \tau[\synSuc(y)/x]}
    \infer3{\Gamma, n : \NN \vdash \synIndN(\synSuc(n),s,t) = t[n/y,\synIndN(n,s,t)/p] : \tau[\synSuc(n)/x]}
  }
\end{mathpar}

\begin{definition}
  A CwF $\cC$ supports the natural number type if the following data are given:
  \begin{itemize}
  \item \emph{formation}: $\typeN \in \Ty{}(\termObj{\cC})$;
  \item \emph{introduction}: a term $\zero \in \Tm{}(\termObj{\cC}, \typeN)$ together with a function $\semSuc_{\Gamma} : \Tm{}(\Gamma, \typeN) \to \Tm{}(\Gamma, \typeN)$;
  \item \emph{elimination}: for each $\tau \in \Ty{}(\Gamma.\typeN)$, a function
    \[
      \indN_{\tau} : \Tm{}(\Gamma,\semSubst{\tau}{\zero}) \times
      \Tm{}(\Gamma.\typeN.\tau,\semSubst{\tau}{\semSuc(v_{\typeN})}) \to
      \Tm{}(\Gamma.\typeN, \semSubst{\tau}{v_{\typeN}})
    \]
  \end{itemize}
  These data are required to be stable under substitution and the following equations must hold:
  \begin{align*}
    \semSubst{\indN_{\tau}(s,t)}{\zero} &= s\\
    \semSubst{\indN_{\tau}(s,t)}{\semSuc(n)} &= \semSubst{\semSubst{t}{n}}{\indN(s,t)}
  \end{align*}
\end{definition}

\begin{example}
  The truth value model supports the natural number type with the following settings:
  \begin{align*}
    \typeN &:= \btt\\
    \zero &:= *\\
    \semSuc &:= \id{}\\
    \indN_{\tau} &:= \bang
  \end{align*}
\end{example}

\subsubsection{Universes}\label{0007}

\begin{mathpar}
  \ebrule[$\cU$-F]{
    \infer0{\vdash \typeJudg{\cU}}
  }\and
  \ebrule[$\El$-F]{
    \hypo{\Gamma \vdash t : \cU}
    \infer1{\Gamma \vdash \typeJudg{\El(t)}}
  }
\end{mathpar}

\begin{definition}
  A universe is \emph{closed under $\synTypeEmpty$ and $\synTypeUnit$} if we additionally have the following rules:
  \begin{mathpar}
    \ebrule[$\synTypeEmpty$-$\cU$]{
      \infer0{\vdash \hat{\synTypeEmpty} : \cU}
    }\and
    \ebrule[$\synTypeUnit$-$\cU$]{
      \infer0{\vdash \hat{\synTypeUnit} : \cU}
    }\and
    \ebrule[$\synTypeEmpty$-$\El$]{
      \infer0{\vdash \typeJudg{\El(\hat{\synTypeEmpty}) = \synTypeEmpty}}
    }\and
    \ebrule[$\synTypeUnit$-$\El$]{
      \infer0{\vdash \typeJudg{\El(\hat{\synTypeUnit}) = \synTypeUnit}}
    }
  \end{mathpar}
\end{definition}

\begin{definition}
  Let $\cC$ be a CwF supporting $\synTypeEmpty$ and $\synTypeUnit$.
  $\cC$ supports a universe closed under $\synTypeEmpty$ and $\synTypeUnit$ if the following data are given:
  \begin{itemize}
  \item \emph{formation}: $\typeU \in \Ty{}(\termObj{\cC})$;
  \item \emph{decoding function}: for each $\Gamma$, a function $\semEl_{\Gamma} : \Tm{}(\Gamma,\typeU) \to \Ty{}(\Gamma)$.
  \item \emph{the empty type}: $\hat{\typeEmpty} \in \Tm{}(\termObj{\cC}, \typeU)$;
  \item \emph{the unit type}: $\hat{\typeUnit} \in \Tm{}(\termObj{\cC}, \typeU)$.
  \end{itemize}
  These data are required to be stable under substitution and the following equations must hold:
  \begin{align*}
    \semEl(\hat{\typeEmpty}) &= \typeEmpty\\
    \semEl(\hat{\typeUnit}) &= \typeUnit
  \end{align*}
\end{definition}

\begin{proposition}\label{0008}
  The truth value model does not support a universe closed under $\synTypeEmpty$ and $\synTypeUnit$.
\end{proposition}
\begin{proof}
  Suppose that it does, then we have $\hat{\typeEmpty} = \hat{\typeUnit}$ since $\Tm{}(\termObj{\TT}, \typeU)$ is a singleton set; hence $\typeEmpty = \typeUnit$.
  By \cref{000A,0009}, this implies that $\bff = \btt$, which is not the case.
\end{proof}

The set model supports a universe closed under more than $\synTypeEmpty$ and $\synTypeUnit$; for instance, we can take the usual Grothendieck universe.

\subsubsection{Dependent product types}\label{sec:spi}

\begin{mathpar}
  \ebrule[$\Pi$-F]{
    \hypo{\Gamma, x : \sigma \vdash \typeJudg{\tau}}
    \infer1{\Gamma \vdash \typeJudg{\Pi x : \sigma.\tau}}
  }\and
  \ebrule[$\Pi$-I]{
    \hypo{\Gamma, x : \sigma \vdash t : \tau}
    \infer1{\Gamma \vdash \lambda x : \sigma.t : \Pi x : \sigma.\tau}
  }\and
  \ebrule[$\Pi$-E]{
    \hypo{\Gamma \vdash f : \Pi x : \sigma.\tau}
    \infer1{\Gamma, u : \sigma \vdash f(u) : \tau[u/x]}
  }\and
  \ebrule[$\Pi$-$\beta$]{
    \hypo{\Gamma, x : \sigma \vdash t : \tau}
    \hypo{\Gamma \vdash s : \sigma}
    \infer2{\Gamma \vdash (\lambda x : \sigma.t)(s) = t[s/x] : \tau[s/x]}
  }%\and
  % \ebrule[$\Pi$-$\eta$]{
  %   \hypo{\Gamma \vdash f : \Pi x : \sigma.\tau}
  %   \infer1{\Gamma \vdash f = \lambda x : \sigma.f(x) : \Pi x : \sigma.\tau}
  % }
\end{mathpar}

\begin{definition}\label{def:spi}
  A CwF $\cC$ supports $\Pi$-types if for any two types $\sigma \in \Ty{\cC}(\Gamma)$ and $\tau \in \Ty{\cC}(\Gamma.\sigma)$, we have the following data:
  \begin{itemize}
  \item \emph{formation}: a type $\typePi(\sigma,\tau) \in \Ty{\cC}(\Gamma)$;
  \item \emph{introduction}: for each term $t \in \Tm{\cC}(\Gamma.\sigma,\tau)$, there is a term $\lam_{\sigma,\tau}(t) \in \Tm{\cC}(\Gamma,\typePi(\sigma,\tau))$;
  \item \emph{elimination}: a morphism in the following configuration:
    % https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXEdhbW1hLlxcc2lnbWEuXFx0eXBlUGkoXFxzaWdtYSxcXHRhdSkiXSxbMCwxLCJcXEdhbW1hLlxcc2lnbWEiXSxbMiwwLCJcXEdhbW1hLlxcc2lnbWEuXFx0YXUiXSxbMCwyLCJcXGFwcF97XFxzaWdtYSxcXHRhdX0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XSxbMCwxLCJcXGN0eEV4dChcXHR5cGVQaShcXHNpZ21hLFxcdGF1KSkiLDJdLFsyLDEsIlxcY3R4RXh0KFxcdGF1KSJdXQ==
    \[\begin{tikzcd}
	{\Gamma.\sigma.\typePi(\sigma,\tau)} && {\Gamma.\sigma.\tau} \\
	{\Gamma.\sigma}
	\arrow["{\app_{\sigma,\tau}}", dotted, from=1-1, to=1-3]
	\arrow["{\ctxExt(\typePi(\sigma,\tau))}"', from=1-1, to=2-1]
	\arrow["{\ctxExt(\tau)}", from=1-3, to=2-1]
      \end{tikzcd}\]
  \end{itemize}
  These data are subject to the following conditions:
  \begin{itemize}
  \item \emph{$\beta$-law}: for every term $t \in \Tm{\cC}(\Gamma.\sigma,\tau)$, the following diagram commutes:
    % https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXEdhbW1hLlxcc2lnbWEuXFxQaShcXHNpZ21hLFxcdGF1KSJdLFsyLDAsIlxcR2FtbWEuXFxzaWdtYS5cXHRhdSJdLFswLDEsIlxcR2FtbWEuXFxzaWdtYSJdLFswLDEsIlxcYXBwX3tcXHNpZ21hLFxcdGF1fSJdLFsyLDAsIlxcbGFtX3tcXHNpZ21hLFxcdGF1fSh0KSJdLFsyLDEsInQiLDJdXQ==
    \[\begin{tikzcd}
	{\Gamma.\sigma.\Pi(\sigma,\tau)} && {\Gamma.\sigma.\tau} \\
	{\Gamma.\sigma}
	\arrow["{\app_{\sigma,\tau}}", from=1-1, to=1-3]
	\arrow["{\lam_{\sigma,\tau}(t)}", from=2-1, to=1-1]
	\arrow["t"', from=2-1, to=1-3]
      \end{tikzcd}\]
  \item \emph{stability under substitution}: for every morphism $f : \Delta \to \Gamma$, one has the following equations:
    \begin{align*}
      \semSubst{\typePi(\sigma,\tau)}{f} &= \typePi(\semSubst{\sigma}{f},\tau)\\
      \semSubst{\lam_{\sigma,\tau}(t)}{f} &= \lam_{\semSubst{\sigma}{f},\tau}(t)
    \end{align*}
    and the following diagram commutes:
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXERlbHRhLlxcc2VtU3Vic3R7XFxzaWdtYX17Zn0uXFx0eXBlUGkoXFxzZW1TdWJzdHtcXHNpZ21hfXtmfSxcXHNlbVN1YnN0e1xcdGF1fXtmfSkiXSxbMiwwLCJcXERlbHRhLlxcc2VtU3Vic3R7XFxzaWdtYX17Zn0uXFxzZW1TdWJzdHtcXHRhdX17Zn0iXSxbMCwxLCJcXEdhbW1hLlxcc2lnbWEuXFx0eXBlUGkoXFxzaWdtYSxcXHRhdSkiXSxbMiwxLCJcXEdhbW1hLlxcc2lnbWEuXFx0YXUiXSxbMiwzLCJcXGFwcF97XFxzaWdtYSxcXHRhdX0iLDJdLFswLDEsIlxcYXBwX3tcXHNlbVN1YnN0e1xcc2lnbWF9e2Z9LFxcc2VtU3Vic3R7XFx0YXV9e2Z9fSJdLFswLDIsIlxcY3R4V2tuKFxcY3R4V2tuKGYsXFxzaWdtYSksXFx0eXBlUGkoXFxzaWdtYSxcXHRhdSkpIiwyXSxbMSwzLCJcXGN0eFdrbihcXGN0eFdrbihmLFxcc2lnbWEpLFxcdGF1KSJdXQ==
    \[\begin{tikzcd}
	{\Delta.\semSubst{\sigma}{f}.\typePi(\semSubst{\sigma}{f},\semSubst{\tau}{f})} && {\Delta.\semSubst{\sigma}{f}.\semSubst{\tau}{f}} \\
	{\Gamma.\sigma.\typePi(\sigma,\tau)} && {\Gamma.\sigma.\tau}
	\arrow["{\app_{\semSubst{\sigma}{f},\semSubst{\tau}{f}}}", from=1-1, to=1-3]
	\arrow["{\ctxWkn(\ctxWkn(f,\sigma),\typePi(\sigma,\tau))}"', from=1-1, to=2-1]
	\arrow["{\ctxWkn(\ctxWkn(f,\sigma),\tau)}", from=1-3, to=2-3]
	\arrow["{\app_{\sigma,\tau}}"', from=2-1, to=2-3]
      \end{tikzcd}\]
  \end{itemize}
\end{definition}

% \begin{construction}
%   Given a CwF that supports $\Pi$-types, we extent the interpretation as follows:
%   \begin{align*}
%     \intp{\ty}{\Gamma;\Pi(\sigma,\tau)} &= \typePi(\intp{\ty}{\Gamma;\sigma},\intp{\ty}{\Gamma, x : \sigma;\tau})\\
%     \intp{\tm}{\Gamma;\lambda x : \sigma. t} &= \lam_{\intp{\ty}{\Gamma;\sigma},\intp{\ty}{\Gamma, x : \sigma;\tau}}(\intp{\tm}{\Gamma,x : \sigma;t})\\
%     \intp{\tm}{\Gamma;u(s)} &= \app_{\intp{\ty}{\Gamma;\sigma},\intp{\ty}{\Gamma, x : \sigma;\tau}} \circ \semComp{\ctxSec{\intp{\tm}{\Gamma;u}}}{\weaken{\intp{\tm}{\Gamma;s}}}{\weaken{\intp{\ty}{\Gamma;\Pi(\sigma,\tau)}}}
%   \end{align*}
% \end{construction}

% The reader may wonder why we presented the elimination form as a morphism rather than a combinator; this seemingly unnatural choice has made the definition somewhat obscure.
% However, this more economical definition is in fact equivalent to the natural one \cite[Proposition 3.16]{Hofmann1997}.

% Intuitively, $\app_{\sigma,\tau}$ maps $(\gamma,s,u) : \Gamma.\tau.\weaken{\typePi(\sigma,\tau)}$ to $(\gamma,s,u(s)) : \Gamma.\sigma.\tau$; then one can project out $u(s)$ via $v_{\tau}$ as follows:
% \[
%   \semSubst{v_{\tau}}{\app_{\sigma,\tau} \circ \semComp{s}{\weaken{u}}{\weaken{\typePi(\sigma,\tau)}}}
% \]

% \begin{definition}\label{def:sspi}
%   A CwF $\cC$ supports strict $\Pi$-types if it supports ordinary $\Pi$-types (\cref{def:spi}) and for any two terms $u \in \Tm{\cC}(\Gamma,\typePi(\sigma,\tau))$ and $s \in \Tm{\cC}(\Gamma.\sigma,\tau)$ such that the following diagram commutes:
%   % https://q.uiver.app/#q=WzAsMyxbMCwxLCJcXEdhbW1hLlxcc2lnbWEiXSxbMCwwLCJcXEdhbW1hLlxcc2lnbWEuXFx3ZWFrZW57XFx0eXBlUGkoXFxzaWdtYSxcXHRhdSl9Il0sWzIsMCwiXFxHYW1tYS5cXHNpZ21hLlxcdGF1Il0sWzEsMiwiXFxhcHBfe1xcc2lnbWEsXFx0YXV9Il0sWzAsMSwiXFxjdHhTZWN7XFx3ZWFrZW57dX19Il0sWzAsMiwiXFxjdHhTZWN7c30iLDJdXQ==
%   \[\begin{tikzcd}
%       {\Gamma.\sigma.\weaken{\typePi(\sigma,\tau)}} && {\Gamma.\sigma.\tau} \\
%       {\Gamma.\sigma}
%       \arrow["{\app_{\sigma,\tau}}", from=1-1, to=1-3]
%       \arrow["{\ctxSec{\weaken{u}}}", from=2-1, to=1-1]
%       \arrow["{\ctxSec{s}}"', from=2-1, to=1-3]
%     \end{tikzcd}\]
%   then one has $u = \lam_{\sigma,\tau}(s)$.
% \end{definition}

% Under the lens of $\lambda$-calculus, the content of \cref{def:sspi} is precisely the $\eta$-law: if $u(x)$ is the expression $s$, then $u$ is the $\lambda$-abstraction of $s$.

\begin{example}
  The term model of a type theory supports $\Pi$-types with the evident settings:
  \begin{align*}
    \typePi(\sigma,\tau) &:= \Pi x : \sigma.\tau\\
    \lam_{\sigma,\tau}(t) &:= \lambda x : \sigma.t
  \end{align*}
  and $\app_{\sigma,\tau}$ is given by the substitution
  \[
    \Gamma,y : \sigma, z : \Pi x : \sigma.\tau \vdash (\gamma,z(y)) : \Gamma, x : \sigma, w : \tau
  \]
  % Moreover, if the underlying type theory has $\eta$-law for $\Pi$-types, then the term model supports them strictly.
\end{example}

\begin{example}\label{000E}
  The truth value model supports $\Pi$-types with the following settings:
  \begin{align*}
    \typePi(\sigma,\tau) &:= \sigma \to \tau\\
    \lam_{\sigma,\tau}(t) &:= *\\
    \app_{\sigma,\tau} &:= \Gamma \wedge \sigma \wedge \typePi(\sigma,\tau) \leq \Gamma \wedge \sigma \wedge \tau
  \end{align*}
\end{example}

\begin{example}
  The set-theoretic model supports $\Pi$-types with the following settings:
  \begin{align*}
    \typePi(\sigma,\tau)_{\gamma} &:= \prod_{x \in \sigma_{\gamma}}\tau_{(\gamma,x)}\\
    \lam_{\sigma,\tau}(t) &:= \lambda\gamma \in \Gamma.\lambda x \in \sigma_{\gamma}.t(\gamma,x)\\
    \app_{\sigma,\tau}(\gamma,x,f) &:= (\gamma,f(x))
  \end{align*}
\end{example}

\subsubsection{Intensional identity types}\label{sec:sid}

\begin{mathpar}
  \ebrule[$\synTypeId$-F]{
    \hypo{\Gamma \vdash a : \sigma}
    \hypo{\Gamma \vdash b : \sigma}
    \infer2{\Gamma \vdash \typeJudg{\synTypeId_{\sigma}(a,b)}}
  }\and
  \ebrule[$\synTypeId$-I]{
    \hypo{\Gamma \vdash a : \sigma}
    \infer1{\Gamma \vdash \synRefl_{\sigma}(a) : \synTypeId_{\sigma}(a,a)}
  }\and
  \ebrule[$\synTypeId$-E]{
    \hypo{
      \begin{matrix}
        \Gamma, x : \sigma, y : \sigma, p : \synTypeId_{\sigma}(x,y) \vdash \typeJudg{\tau}\\
        \Gamma, z : \sigma \vdash s : \tau[z/x,z/y,\synRefl_{\sigma}(z)/p]\\
      \end{matrix}
    }
    \infer1{\Gamma, x : \sigma, y : \sigma, p : \synTypeId_{\sigma}(x,y) \vdash \synIndId(p,s) : \tau}
  }\and
  \ebrule[$\synTypeId$-$\beta$]{
    \hypo{\Gamma \vdash a : \sigma}
    \hypo{\Gamma, z : \sigma \vdash s : \tau[z/x,z/y,\synRefl_{\sigma}(z)/p]}
    \infer2{\Gamma \vdash \synIndId(\synRefl_{\sigma}(a),s) = s[a/z] : \tau[a/x,a/y,\synRefl_{\sigma}(a)/p]}
  }
\end{mathpar}
% \begin{itemize}
% \item \emph{$\beta$-law}: $\synIndId(\synRefl_{\sigma}(a),s) = s[a/z] : \tau[a/x,a/y,\synRefl_{\sigma}(a)/p]$.
% \item \emph{$\eta$-law (extensional type theory)}: $p = \synRefl_{\sigma}(a) : \synTypeId(a,b)$.
% \end{itemize}
% Note that the $\eta$-law does not type check without the \emph{equality reflection} rule:
% \begin{mathpar}
%   \ebrule{
%     \hypo{\Gamma \vdash p : \synTypeId_{\sigma}(a,b)}
%     \infer1{\Gamma \vdash a = b : \sigma}
%   }
% \end{mathpar}

\begin{definition}\label{def:sid}
  A CwF $\cC$ supports (intensional) identity types if for every $\sigma \in \Ty{\cC}(\Gamma)$, the following data are given:
  \begin{itemize}
  \item \emph{formation}: a type $\typeId_{\sigma} \in \Ty{\cC}(\Gamma.\sigma.\sigma)$;
  \item \emph{introduction}: a morphism $\refl_{\sigma} : \Gamma.\sigma \to \Gamma.\sigma.\sigma.\typeId_{\sigma}$ in the following configuration:
    % https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXEdhbW1hLlxcc2lnbWEiXSxbMiwwLCJcXEdhbW1hLlxcc2lnbWEuXFxzaWdtYS5cXHR5cGVJZF97XFxzaWdtYX0iXSxbMCwxLCJcXEdhbW1hLlxcc2lnbWEuXFxzaWdtYSJdLFswLDEsIlxccmVmbF97XFxzaWdtYX0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XSxbMSwyLCJcXGN0eEV4dChcXHR5cGVJZF97XFxzaWdtYX0pIl0sWzAsMiwidl97XFxzaWdtYX0iLDJdXQ==
    \[\begin{tikzcd}
	{\Gamma.\sigma} && {\Gamma.\sigma.\sigma.\typeId_{\sigma}} \\
	{\Gamma.\sigma.\sigma}
	\arrow["{\refl_{\sigma}}", dotted, from=1-1, to=1-3]
	\arrow["{v_{\sigma}}"', from=1-1, to=2-1]
	\arrow["{\ctxExt(\typeId_{\sigma})}", from=1-3, to=2-1]
      \end{tikzcd}\]
  \item \emph{elimination}: for each type $\tau \in \Ty{\cC}(\Gamma.\sigma.\sigma.\typeId_{\sigma})$, a function $\indId_{\sigma,\tau} : \Tm{\cC}(\Gamma.\sigma,\semSubst{\tau}{\refl_{\sigma}}) \to \Tm{\cC}(\Gamma.\sigma.\sigma.\typeId_{\sigma},\tau)$.
  \end{itemize}
  These data are required to be stable under substitution and additionally the following equation holds for every term $t \in \Tm{\cC}(\Gamma.\tau,\semSubst{\tau}{\refl_{\sigma}})$:
  \begin{align*}
    \semSubst{\indId_{\sigma,\tau}(t)}{\refl_{\sigma}} = t && \text{$\beta$-law}
  \end{align*}
\end{definition}

% \begin{construction}
%   We extend the interpretation function as follows:
%   \begin{align*}
%     \intp{\ty}{\Gamma;\synTypeId(u,s)} &= \semSubst{\typeId}{\semComp{\ctxSec{\intp{\tm}{\Gamma;u}}}{\weaken{\intp{\tm}{\Gamma;s}}}{}}\\
%     \intp{\tm}{\Gamma;\synRefl(a)} &= \refl \circ \ctxSec{\intp{\tm}{\Gamma;a}}\\
%     \intp{\tm}{\Gamma;\synIndId(u,s)} &= \semSubst{\indId(\intp{\tm}{\Gamma,z:\sigma;s})}{\semComp{-,-}{\weaken{\intp{\tm}{\Gamma;u}}}{}}
%   \end{align*}
% \end{construction}

\begin{example}
  The term model of intensional type theory supports identity types with the following settings:
  \begin{align*}
    \typeId_{\sigma} &:= \Gamma, x : \sigma, y : \sigma \vdash \typeJudg{\synTypeId_{\sigma}(x,y)}\\
    \refl_{\sigma} &:= \Gamma, x : \sigma \vdash (\gamma,x,x,\synRefl_{\sigma}(x)) : \Gamma, x : \sigma, y : \sigma, p : \synTypeId_{\sigma}(x,x)\\
    \indId_{\sigma,\tau}(t) &:= \synIndId(p,t)
  \end{align*}
  where $p$ is a free variable.
\end{example}

\begin{example}\label{000D}
  The truth value model supports identity types with the following settings:
  \begin{align*}
    \typeId_{\sigma} &:= \btt\\
    \refl_{\sigma} &:= \Gamma \wedge \sigma \leq \Gamma \wedge \sigma \wedge \sigma \wedge \typeId_{\sigma}\\
    \indId_{\sigma,\tau} &:= \bang
  \end{align*}
\end{example}

\begin{example}
  The set model supports identity types with the following settings:
  \begin{align*}
    \prn{\typeId_{\sigma}}_{(\gamma,x,y)} &:=
                                  \begin{cases}
                                    \termObj{\Set} & \text{if $x = y$;}\\
                                    \initObj{\Set} & \text{otherwise}
                                  \end{cases}\\
    \refl_{\sigma}(\gamma,x) &:= (\gamma,x,x,*)\\
    \indId_{\sigma,\tau}(s)(\gamma,x,y,p) &:= s(\gamma,x)
  \end{align*}
\end{example}

\subsubsection{Dependent sum types}\label{sec:ssig}

\begin{mathpar}
  \ebrule[$\Sigma$-F]{
    \hypo{\Gamma, x : \sigma \vdash \typeJudg{\tau}}
    \infer1{\Gamma \vdash \typeJudg{\Sigma x : \sigma.\tau}}
  }\and
  \ebrule[$\Sigma$-I]{
    \hypo{\Gamma \vdash a : \sigma}
    \hypo{\Gamma \vdash b : \tau[a/x]}
    \infer2{\Gamma \vdash \synPair{a}{b} : \Sigma x : \sigma.\tau}
  }\and
  \ebrule[$\Sigma$-E]{
    \hypo{
      \begin{matrix}
        \Gamma,z : \Sigma x : \sigma.\tau \vdash \typeJudg{\rho}\\
        \Gamma,x : \sigma, y : \tau \vdash s : \rho[\synPair{x}{y}/z]\\
      \end{matrix}
    }
    \infer1{\Gamma, z : \Sigma x : \sigma.\tau \vdash \synIndSig(z,s) : \rho}
  }\and
  \ebrule[$\Sigma$-$\beta$]{
    \hypo{\Gamma \vdash a : \sigma}
    \hypo{\Gamma \vdash b : \tau[a/x]}
    \hypo{\Gamma,x : \sigma, y : \tau \vdash s : \rho[\synPair{x}{y}/z]}
    \infer3{\synIndSig(\synPair{a}{b},s) = s[a/x,b/y] : \rho[\synPair{a}{b}/z]}
  }
\end{mathpar}
% \begin{itemize}
% \item \emph{$\beta$-law}: $\synIndSig(\synPair{a}{b},s) = s[a/x,b/y] : \tau[\synPair{a}{b}/z]$;
% \item \emph{$\eta$-law (optional)}: $u = \synPair{\synIndSig(u,x)}{\synIndSig(u,y)} : \Sigma x : \sigma.\tau$.
% \end{itemize}

\begin{definition}
  A CwF $\cC$ supports $\Sigma$-types if the following data are given for any two types $\sigma \in \Ty{\cC}(\Gamma)$ and $\tau \in \Ty{\cC}(\Gamma.\sigma)$:
  \begin{itemize}
  \item \emph{formation}: a type $\typeSig(\sigma,\tau) \in \Ty{\cC}(\Gamma)$;
  \item \emph{introduction}: a morphism in the following configuration:
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXEdhbW1hLlxcc2lnbWEuXFx0YXUiXSxbMiwwLCJcXEdhbW1hLlxcdHlwZVNpZyhcXHNpZ21hLFxcdGF1KSJdLFsyLDEsIlxcR2FtbWEiXSxbMCwxLCJcXEdhbW1hLlxcc2lnbWEiXSxbMCwxLCJcXHBhaXJfe1xcc2lnbWEsXFx0YXV9IiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZG90dGVkIn19fV0sWzEsMiwiXFxjdHhFeHQoXFx0eXBlU2lnKFxcc2lnbWEsXFx0YXUpKSJdLFswLDMsIlxcY3R4RXh0KFxcdGF1KSIsMl0sWzMsMiwiXFxjdHhFeHQoXFxzaWdtYSkiLDJdXQ==
    \[\begin{tikzcd}
	{\Gamma.\sigma.\tau} && {\Gamma.\typeSig(\sigma,\tau)} \\
	{\Gamma.\sigma} && \Gamma
	\arrow["{\pair_{\sigma,\tau}}", dotted, from=1-1, to=1-3]
	\arrow["{\ctxExt(\tau)}"', from=1-1, to=2-1]
	\arrow["{\ctxExt(\typeSig(\sigma,\tau))}", from=1-3, to=2-3]
	\arrow["{\ctxExt(\sigma)}"', from=2-1, to=2-3]
      \end{tikzcd}\]
  \item \emph{elimination}: for every type $\rho \in \Ty{\cC}(\Gamma.\typeSig(\sigma,\tau))$ and term $t \in \Tm{\cC}(\Gamma.\sigma.\tau,\semSubst{\rho}{\pair_{\sigma,\tau}})$, a term $\indSig_{\sigma,\tau,\rho}(t) \in \Tm{\cC}(\Gamma.\typeSig(\sigma,\tau),\rho)$.
  \end{itemize}
  These data are subject to the following conditions:
  \begin{itemize}
  \item \emph{$\beta$-law}: for every type $\rho \in \Ty{\cC}(\Gamma.\typeSig(\sigma,\tau))$ and term $t \in \Tm{\cC}(\Gamma.\sigma.\tau,\semSubst{\rho}{\pair_{\sigma,\tau}})$, the equation $\semSubst{\indSig_{\sigma,\tau,\rho}(t)}{\pair_{\sigma,\tau}} = t$ holds;
  \item stability under substitution.%: for any morphism $f : \Delta \to \Gamma$ the following equations hold:
    % \begin{align*}
  %   \semSubst{\typeSig(\sigma,\tau)}{f} &= \typeSig(\semSubst{\sigma}{f},\weaken{\tau})\\
  %   \semSubst{\indSig_{\sigma,\tau,\tau}(t)}{\ctxWkn(f,\typeSig(\sigma,\tau))} &= \indSig_{\semSubst{\sigma}{f},\weaken{\tau},\weaken{\tau}}(\weaken{t})
    % \end{align*}
    % and the following diagram commutes:
    %     % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXERlbHRhLlxcc2VtU3Vic3R7XFxzaWdtYX17Zn0uXFx3ZWFrZW57XFx0YXV9Il0sWzIsMCwiXFxEZWx0YS5cXHR5cGVTaWcoXFxzZW1TdWJzdHtcXHNpZ21hfXtmfSxcXHdlYWtlbntcXHRhdX0pIl0sWzAsMSwiXFxHYW1tYS5cXHNpZ21hLlxcdGF1Il0sWzIsMSwiXFxHYW1tYS5cXHR5cGVTaWcoXFxzaWdtYSxcXHRhdSkiXSxbMiwzLCJcXHBhaXJfe1xcc2lnbWEsXFx0YXV9IiwyXSxbMCwxLCJcXHBhaXJfe1xcc2VtU3Vic3R7XFxzaWdtYX17Zn0sXFx3ZWFrZW57XFx0YXV9fSJdLFswLDIsIlxcY3R4V2tuKFxcY3R4V2tuKGYsXFxzaWdtYSksXFx0YXUpIiwyXSxbMSwzLCJcXGN0eFdrbihmLFxcdHlwZVNpZyhcXHNpZ21hLFxcdGF1KSkiXV0=
    % \[\begin{tikzcd}
    %     {\Delta.\semSubst{\sigma}{f}.\weaken{\tau}} && {\Delta.\typeSig(\semSubst{\sigma}{f},\weaken{\tau})} \\
    %     {\Gamma.\sigma.\tau} && {\Gamma.\typeSig(\sigma,\tau)}
    %     \arrow["{\pair_{\semSubst{\sigma}{f},\weaken{\tau}}}", from=1-1, to=1-3]
    %     \arrow["{\ctxWkn(\ctxWkn(f,\sigma),\tau)}"', from=1-1, to=2-1]
    %     \arrow["{\ctxWkn(f,\typeSig(\sigma,\tau))}", from=1-3, to=2-3]
    %     \arrow["{\pair_{\sigma,\tau}}"', from=2-1, to=2-3]
%       \end{tikzcd}\]
  \end{itemize}
 \end{definition}

% For space reason, we suppress typing annotations when it is appropriate.
% \begin{construction}
%   Given a CwF that supports $\Sigma$-types, we extend the interpretation function as follows:
%   \begin{align*}
%     \intp{\ty}{\Gamma;\Sigma(\sigma,\tau)} &= \typeSig(\intp{\ty}{\Gamma;\sigma},\intp{\ty}{\Gamma, x : \sigma;\tau})\\
%     \intp{\tm}{\Gamma;\synPair{a}{b}} &= \pair_{\sigma,\tau} \circ \semComp{\ctxSec{\intp{\tm}{\Gamma;a}}}{\weaken{\intp{\tm}{\Gamma,x:\sigma;b}}}{\weaken{\intp{\ty}{\Gamma,x:\sigma;\tau}}}\\
%     \intp{\tm}{\Gamma;\synIndSig(u,s)} &= \semSubst{\indSig(\intp{\tm}{\Gamma,x:\sigma,y:\tau;s})}{\ctxSec{\intp{\tm}{\Gamma;u}}}
%   \end{align*}
% \end{construction}

\begin{example}
  The term model supports $\Sigma$-types with the following settings:
  \begin{align*}
    \typeSig(\sigma,\tau) &:= \Sigma x : \sigma.\tau\\
    \pair_{\sigma,\tau} &:= \Gamma, x : \sigma, y : \tau \vdash (\gamma, \synPair{u}{s}) : \Gamma, z : \Sigma x : \sigma.\tau\\
    \indSig_{\sigma,\tau,\rho}(s) &:= \synIndSig(x,s)
  \end{align*}
  where $x : \Sigma x : \sigma.\tau$ is a free variable.
\end{example}

\begin{example}\label{000C}
  The truth value model supports $\Sigma$-types with the following settings:
  \begin{align*}
    \typeSig(\sigma,\tau) &:= \sigma \wedge \tau\\
    \pair_{\sigma,\tau} &:= \Gamma \wedge \sigma \wedge \tau \leq \Gamma \wedge \typeSig(\sigma,\tau)\\
    \indSig_{\sigma,\tau,\rho} &:= \bang
  \end{align*}
\end{example}

\begin{example}
  The set model supports $\Sigma$-types with the following settings:
  \begin{align*}
    \typeSig(\sigma,\tau)_{\gamma \in \Gamma} &:= \setNotat{(x,y) : x \in \sigma_{\gamma}, y \in \tau_{(\gamma,x)}}\\
    \pair_{\sigma,\tau}(\gamma,x,y) &:= (\gamma,(x,y))\\
    \indSig_{\sigma,\tau,\rho}(s) &:= \lambda(\gamma,(x,y)) \in \Gamma.\typeSig(\sigma,\tau).s(\gamma,x,y)
  \end{align*}
  % Observe that $\pair_{\sigma,\tau}$ is a bijection; hence the set-theoretic model in fact supports strict $\Sigma$-types.
\end{example}

\section{Peano's 4th axiom}\label{000B}

A famous example in an introduction to type theory course is to show that $0$ is not $1$, \ie the type $\synTypeId(0,\synSuc(0)) \to \synTypeEmpty$ is inhabited.
The proof (in Agda) usually goes as follows.
First, we define the following function that essentially characterizes equality on the natural numbers:

\begin{minted}{agda}
  eq : nat -> nat -> Set
  eq z z = unit
  eq z (suc n) = empty
  eq (suc m) z = empty
  eq (suc m) (suc n) = eq m n
\end{minted}
where \mintinline{agda}{Set} is a universe closed under $\synTypeEmpty$ and $\synTypeUnit$.

Then we show that \mintinline{agda}{eq} is complete for $\synTypeId_{\NN}(x,y)$, \ie if $\synTypeId_{\NN}(x,y)$, then \mintinline{agda}{eq x y} is inhabited.

\begin{minted}{agda}
  complete : (x y : nat) -> Id x y -> eq x y
  complete z .z (refl .z) = *
  complete (suc x) .(suc x) (refl .(suc x)) = complete x x (refl x)
\end{minted}

And finally, we can now easily find a term of type $\synTypeId(0,\synSuc(0)) \to \synTypeEmpty$.

\begin{minted}{agda}
  pa4 : Id 0 (suc 0) -> empty
  pa4 p = complete 0 (suc 0) p
\end{minted}

\begin{remark}
  Doing a pattern match on \mintinline{agda}{p} is cheating.
\end{remark}

In hindsight, it is not clear why we need to bother with the function \mintinline{agda}{eq}.
The following proposition shows that it is necessary.

\begin{proposition}
  The type $\synTypeId(0,\synSuc(0)) \to \synTypeEmpty$ is not inhabited in a Martin-L\"of type theory $\cT$ without universes.
\end{proposition}
\begin{proof}
  If the type is inhabited, then $\Tm{}(\termObj{\cC}, \semSubst{\typeId_{\typeN}}{\zero, \semSuc(\zero)} \to \typeEmpty)$ is not empty for all CwF $\cC$ that supports $\cT$.
  
  Since $\cT$ has no universes, it can be interpreted into the truth value model; but $\Tm{}(\termObj{\TT}, \semSubst{\typeId_{\typeN}}{\zero, \semSuc(\zero)} \to \typeEmpty)$ is empty because the latter type is interpreted as the exponential $\btt \to \bff$, \ie $\bff$.
\end{proof}

% \subsubsection{The presheaf model}\label{sec:tpm}

% Given a type theory $\cT$, we may take the term model as a presentation of $\cT$.
% We use the same notation, $\cT$, for the term model.
% We can embed $\cT$ into the \emph{meta}-language $\Pr(\cT)$.
% A meta-context $\fG$ is a presheaf $\cT\op \to \Set$ that realizes each context $\Gamma$ in the object language as a set and each substitution as a function.
% We can compress this data into the so-called \emph{category of elements} $\El(\fG)$.

% A meta-type in the meta-context $\fG$ is a presheaf $\sigma : \El(\fG)\op \to \Set$ that maps each stage $(\Gamma,\gamma)$ to a set of meta-terms.
% Then a meta-term of type $\sigma$ at stage $(\Gamma,\gamma)$ is an element in $\sigma(\Gamma,\gamma)$.

% \subsection{Conservativity of the logical framework}\label{sec:cotlf}

% \begin{proposition}[Conservativity]
%   If $\Gamma \dvdash{\cT} \typeJudg{\sigma}$ and $\Gamma \dvdash{\LF{\cT}} t : \sigma$ for some term $t$, then there exists a term $t'$ such that $\Gamma \dvdash{\cT} t' : \sigma$.
% \end{proposition}
% \begin{proof}
%   Suppose that $\Gamma \dvdash{\cT} \typeJudg{\sigma}$.
%   By assumption $\Hom{\Pr(\cT)}(\yon_{\Gamma},\yon_{\sigma})$ is not empty; hence $\Hom{\cT}(\Gamma,\sigma)$ is not empty by fullness.
% \end{proof}

% \subsection{Dependent sum types}\label{sec:dst}



% \subsection{Identity types}\label{sec:it}


% \subsection{Universes}\label{sec:u}

% \begin{mathpar}
%   \ebrule[$U$-F]{
%     \infer0{\Gamma \vdash \typeJudg{U}}
%   }\and
%   \ebrule[$\El$-I]{
%     \hypo{\Gamma \vdash \sigma : U}
%     \infer1{\Gamma \vdash \typeJudg{\El(\sigma)}}
%   }
% \end{mathpar}

% \subsection{Logical framework}\label{sec:eott}

% Martin-L\"of's Logical Framework (LF) is a type theory with $\Pi$-types and a universe.
% Other theories can be defined as extensions of the LF by constants and equations.
% For instance, $\Sigma$-types can be encoded in LF as follows:

% \begin{align*}
%   &\vdash \objSig : \LFPi \sigma : \LFU. \LFPi \tau : \sigma \to \LFU. \LFU\\
%   &\vdash \objPair : \LFPi \sigma : \LFU. \LFPi \tau : \sigma \to \LFU.\LFPi x : \sigma. \tau(x) \to \objSig(\sigma,\tau)\\
%   &\vdash \objIndSig : \LFPi \sigma : \LFU. \LFPi \tau : \sigma \to \LFU. \LFPi \tau : \objSig(\sigma, \tau) \to \LFU.\\
%   &\qquad\prn{\LFPi x : \sigma. \LFPi y : \tau(x). \tau(\objPair(\sigma,\tau,x,y))} \to\\
%   &\qquad\LFPi z : \objSig(\sigma,\tau). \tau(z)\\
%   &\Gamma \vdash \objIndSig(\sigma,\tau,\tau,f,\objPair(\sigma,\tau,a,b)) = f(a)(b)
% \end{align*}
% where $\Gamma$ declares the variables used on the right-hand side.

% Compare this to the $\Sigma$-types defined in the hand-crafted formalism above; binding in the object language is represented as abstraction in the LF and substitution in the object language is represented as application in the LF.
% The burden of dealing with binding and substitution is shifted from the object language to the LF.

\bibliography{semdtt}
\bibliographystyle{alpha}

\end{document}
